import numpy as np
import pytest

from eradiate import unit_registry as ureg
from eradiate.contexts import KernelDictContext
from eradiate.experiments._rami import RamiExperiment
from eradiate.scenes.biosphere import DiscreteCanopy
from eradiate.scenes.measure import MultiDistantMeasure


def test_rami_experiment_construct_default(mode_mono):
    """
    RamiExperiment initialises with default params in all modes
    """
    assert RamiExperiment()


def test_rami_experiment_construct_measures(mode_mono):
    """
    A variety of measure specifications are acceptable
    """

    # Init with a single measure (not wrapped in a sequence)
    assert RamiExperiment(measures=MultiDistantMeasure())

    # Init from a dict-based measure spec
    # -- Correctly wrapped in a sequence
    assert RamiExperiment(measures=[{"type": "distant"}])
    # -- Not wrapped in a sequence
    assert RamiExperiment(measures={"type": "distant"})


@pytest.mark.parametrize("padding", (0, 1))
def test_rami_experiment_construct_normalize_measures(mode_mono, padding):
    """
    When canopy is not None, measure target matches canopy unit cell
    """
    exp = RamiExperiment(
        canopy=DiscreteCanopy.homogeneous(
            lai=3.0,
            leaf_radius=0.1 * ureg.m,
            l_horizontal=10.0 * ureg.m,
            l_vertical=2.0 * ureg.m,
            padding=padding,
        ),
        measures=MultiDistantMeasure(),
    )
    target = exp.measures[0].target
    canopy = exp.canopy
    assert np.isclose(target.xmin, -0.5 * canopy.size[0])
    assert np.isclose(target.xmax, 0.5 * canopy.size[0])
    assert np.isclose(target.ymin, -0.5 * canopy.size[1])
    assert np.isclose(target.ymax, 0.5 * canopy.size[1])


@pytest.mark.parametrize("padding", (0, 1))
def test_rami_experiment_kernel_dict(mode_mono, padding):
    ctx = KernelDictContext()

    # Surface width is appropriately inherited from canopy
    s = RamiExperiment(
        canopy=DiscreteCanopy.homogeneous(
            lai=3.0,
            leaf_radius=0.1 * ureg.m,
            l_horizontal=10.0 * ureg.m,
            l_vertical=2.0 * ureg.m,
            padding=padding,
        )
    )
    kernel_scene = s.kernel_dict(ctx)
    assert np.allclose(
        kernel_scene["surface"]["to_world"].transform_point([1, -1, 0]),
        [5 * (2 * padding + 1), -5 * (2 * padding + 1), 0],
    )


@pytest.mark.slow
def test_rami_experiment_real_life(mode_mono):
    ctx = KernelDictContext()

    # Construct with typical parameters
    exp = RamiExperiment(
        surface={"type": "lambertian"},
        canopy={
            "type": "discrete_canopy",
            "construct": "homogeneous",
            "lai": 3.0,
            "leaf_radius": 0.1 * ureg.m,
            "l_horizontal": 10.0 * ureg.m,
            "l_vertical": 2.0 * ureg.m,
        },
        illumination={"type": "directional", "zenith": 45.0},
        measures={"type": "distant_reflectance"},
    )
    assert exp.kernel_dict(ctx=ctx).load() is not None


@pytest.mark.slow
def test_rami_experiment_run_detailed(mode_mono):
    """
    Test for correctness of the result dataset generated by RamiExperiment.
    Note: This test is outdated, most of its content should be transferred to
    tests for measure post-processing pipelines.
    """
    exp = RamiExperiment(
        measures=[
            {
                "type": "distant_reflectance",
                "id": "toa_hsphere",
                "film_resolution": (32, 32),
                "spp": 1000,
            },
        ]
    )

    exp.run()

    results = exp.results["toa_hsphere"]

    # Post-processing creates expected variables ...
    assert set(results.data_vars) == {"irradiance", "brf", "brdf", "lo", "spp"}

    # ... dimensions
    assert set(results["lo"].dims) == {"sza", "saa", "x", "y", "w"}
    assert set(results["irradiance"].dims) == {"sza", "saa", "w"}

    # ... and other coordinates
    assert set(results["lo"].coords) == {
        "sza",
        "saa",
        "vza",
        "vaa",
        "x",
        "y",
        "w",
    }
    assert set(results["irradiance"].coords) == {"sza", "saa", "w"}

    # We just check that we record something as expected
    assert np.all(results["lo"].data > 0.0)
